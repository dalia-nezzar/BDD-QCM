import streamlit as st
import random
import json
from datetime import datetime

# Configuration de la page
st.set_page_config(
    page_title="QCM Administration Avanc√©e BDD",
    page_icon="üóÑÔ∏è",
    layout="wide"
)

# Initialisation du state
if 'current_question' not in st.session_state:
    st.session_state.current_question = 0
if 'score' not in st.session_state:
    st.session_state.score = 0
if 'answers' not in st.session_state:
    st.session_state.answers = []
if 'quiz_started' not in st.session_state:
    st.session_state.quiz_started = False
if 'quiz_finished' not in st.session_state:
    st.session_state.quiz_finished = False

# Base de questions du QCM
questions = [
    {
        "type": "mcq",
        "question": "Quelle est la taille par d√©faut d'un segment de journal des transactions (WAL) dans PostgreSQL ?",
        "options": ["8 Mo", "16 Mo", "32 Mo", "64 Mo"],
        "correct": 1,
        "explanation": "PostgreSQL organise le journal des transactions en segments de 16 Mo par d√©faut."
    },
    {
        "type": "multiple",
        "question": "Quels sont les niveaux de s√©curit√© dans PostgreSQL ? (Plusieurs r√©ponses possibles)",
        "options": [
            "Network authentication (pg_hba.conf)",
            "Instance-level permissions",
            "Database-level permissions",
            "Table-level permissions",
            "Column permissions"
        ],
        "correct": [0, 1, 2, 3, 4],
        "explanation": "PostgreSQL utilise 7 niveaux de s√©curit√© : TCP on/off, Network auth, Instance, Database, Schema, Table, et Column permissions."
    },
    {
        "type": "code",
        "question": "Compl√©tez cette commande pour cr√©er un tablespace :",
        "code_template": "CREATE TABLESPACE mon_espace OWNER postgres _______ '/chemin/vers/le/dossier';",
        "correct": "LOCATION",
        "explanation": "La syntaxe correcte est : CREATE TABLESPACE mon_espace OWNER postgres LOCATION '/chemin/vers/le/dossier';"
    },
    {
        "type": "mcq",
        "question": "Quel est le but principal du journal des transactions (WAL) ?",
        "options": [
            "Am√©liorer les performances des requ√™tes",
            "Garantir qu'une instance DB puisse survivre aux pannes",
            "Stocker les donn√©es utilisateur",
            "G√©rer les connexions utilisateur"
        ],
        "correct": 1,
        "explanation": "Le WAL (Write Ahead Log) garantit qu'une instance de base de donn√©es puisse survivre aux pannes en cas de crash du syst√®me."
    },
    {
        "type": "multiple",
        "question": "Quels sont les deux types de sauvegarde sous PostgreSQL ?",
        "options": [
            "Sauvegarde logique (SQL dump)",
            "Sauvegarde physique (File system level)",
            "Sauvegarde incr√©mentale",
            "Sauvegarde diff√©rentielle"
        ],
        "correct": [0, 1],
        "explanation": "PostgreSQL propose deux approches : sauvegarde logique (SQL dump) et sauvegarde physique (File system level backup)."
    },
    {
        "type": "code",
        "question": "Quelle commande permet de cr√©er un utilisateur avec privil√®ge de cr√©ation de base de donn√©es ?",
        "code_template": "CREATE USER nom_utilisateur _______;",
        "correct": "CREATEDB",
        "explanation": "La commande correcte est : CREATE USER nom_utilisateur CREATEDB;"
    },
    {
        "type": "mcq",
        "question": "Quelle est la diff√©rence principale entre r√©plication synchrone et asynchrone ?",
        "options": [
            "La r√©plication synchrone est plus rapide",
            "La r√©plication asynchrone garantit la coh√©rence",
            "La r√©plication synchrone attend la confirmation avant de valider",
            "Il n'y a pas de diff√©rence"
        ],
        "correct": 2,
        "explanation": "En r√©plication synchrone, les transactions doivent √™tre confirm√©es par tous les serveurs avant d'√™tre valid√©es, contrairement √† l'asynchrone."
    },
    {
        "type": "multiple",
        "question": "Quels sont les avantages de l'internationalisation (i18n) dans PostgreSQL ?",
        "options": [
            "Support de l'encodage UTF-8",
            "Gestion des collations",
            "Formats de date et heure r√©gionaux",
            "Messages d'erreur multilingues"
        ],
        "correct": [0, 1, 2, 3],
        "explanation": "PostgreSQL supporte l'i18n avec UTF-8, collations, formats r√©gionaux et messages multilingues."
    },
    {
        "type": "code",
        "question": "Compl√©tez la commande pour sauvegarder une base de donn√©es avec pg_dump :",
        "code_template": "pg_dump _______ > backup.sql",
        "correct": "dbname",
        "explanation": "La syntaxe correcte est : pg_dump dbname > backup.sql"
    },
    {
        "type": "mcq",
        "question": "Quel param√®tre contr√¥le l'intervalle entre les checkpoints ?",
        "options": [
            "wal_level",
            "checkpoint_segments",
            "max_wal_senders",
            "archive_mode"
        ],
        "correct": 1,
        "explanation": "checkpoint_segments contr√¥le l'intervalle entre les checkpoints (par d√©faut 3 segments = 3 * 16 MB)."
    },
    {
        "type": "multiple",
        "question": "Quels sont les types de bases NoSQL mentionn√©s dans le cours ?",
        "options": [
            "Document (MongoDB)",
            "Cl√©-Valeur (Redis)",
            "Colonnes (Cassandra)",
            "Graphes (Neo4j)"
        ],
        "correct": [0, 1, 2, 3],
        "explanation": "Les 4 types principaux de NoSQL sont : Document, Cl√©-Valeur, Colonnes orient√©es, et Graphes."
    },
    {
        "type": "code",
        "question": "Compl√©tez la commande pour accorder des privil√®ges SELECT √† un utilisateur :",
        "code_template": "GRANT SELECT ON table_name __ user_name;",
        "correct": "TO",
        "explanation": "La syntaxe correcte est : GRANT SELECT ON table_name TO user_name;"
    },
{
        "type": "mcq",
        "question": "Quel processus est responsable de l'ex√©cution de la t√¢che autovacuum dans PostgreSQL ?",
        "options": [
            "autovacuum launcher",
            "bgwriter",
            "checkpointer",
            "walwriter"
        ],
        "correct": 0,
        "explanation": "Le processus autovacuum launcher est charg√© de lancer p√©riodiquement les workers autovacuum pour nettoyer et analyser les tables."
    },
    {
        "type": "mcq",
        "question": "Quel param√®tre configure les noms des serveurs standby synchrones dans PostgreSQL ?",
        "options": [
            "synchronous_commit",
            "synchronous_standby_names",
            "max_wal_senders",
            "wal_level"
        ],
        "correct": 1,
        "explanation": "synchronous_standby_names d√©finit la liste des serveurs standby qui doivent confirmer l'√©criture des WAL avant de valider une transaction en mode synchrone."
    },
    {
        "type": "mcq",
        "question": "Que signifie l'acronyme RPO en gestion de la reprise apr√®s sinistre ?",
        "options": [
            "Recovery Point Objective",
            "Recovery Performance Objective",
            "Restore Point Option",
            "Replication Process Optimization"
        ],
        "correct": 0,
        "explanation": "Le Recovery Point Objective (RPO) est le point dans le temps auquel on peut revenir apr√®s une panne, d√©finissant la quantit√© maximale de donn√©es perdue acceptable."
    },
    {
        "type": "code",
        "question": "Compl√©tez la commande pour activer l'extension FDW PostgreSQL :",
        "code_template": "CREATE EXTENSION ________;  ",
        "correct": "postgres_fdw",
        "explanation": "L'extension postgres_fdw est utilis√©e pour cr√©er des Foreign Data Wrappers afin d'acc√©der √† des tables distantes."
    },
    {
        "type": "code",
        "question": "Compl√©tez la commande pour ajouter un utilisateur √† un groupe :",
        "code_template": "ALTER GROUP nom_groupe ________ nom_utilisateur;",
        "correct": "ADD USER",
        "explanation": "La syntaxe ALTER GROUP nom_groupe ADD USER nom_utilisateur permet d'ajouter un utilisateur au groupe."
    },
    {
        "type": "code",
        "question": "Compl√©tez la commande pg_dump pour se connecter √† un serveur distant avec authentification :",
        "code_template": "pg_dump -h host -p port -U ________ dbname > backup.sql",
        "correct": "nom_utilisateur",
        "explanation": "Le param√®tre -U est suivi du nom d'utilisateur pour l'authentification lors de l'utilisation de pg_dump."
    },
    {
        "type": "multiple",
        "question": "Quelles sont les fonctionnalit√©s prises en charge par le Write-Ahead Log (WAL) ?",
        "options": [
            "Durabilit√© des transactions",
            "R√©plication vers les standbys",
            "Optimisation des requ√™tes SELECT",
            "Recovery Point-in-Time (PITR)",
            "Gestion des verrous"
        ],
        "correct": [0, 1, 3],
        "explanation": "Le WAL assure la durabilit√© des transactions, le support de la r√©plication et permet le point-in-time recovery, mais n'optimise pas directement les requ√™tes ni g√®re les verrous."
    },
    {
        "type": "multiple",
        "question": "Selon le th√©or√®me CAP, quelles sont les trois garanties que tout syst√®me distribu√© ne peut satisfaire simultan√©ment ?",
        "options": [
            "Coh√©rence (Consistency)",
            "Haute disponibilit√© (Availability)",
            "Tol√©rance au partitionnement (Partition Tolerance)",
            "Durabilit√© (Durability)",
            "Scalabilit√© (Scalability)"
        ],
        "correct": [0, 1, 2],
        "explanation": "Le th√©or√®me CAP stipule qu'un syst√®me distribu√© ne peut simultan√©ment garantir la coh√©rence, la disponibilit√© et la tol√©rance aux partitions."
    },
    {
        "type": "mcq",
        "question": "Quel catalogue syst√®me stocke les informations sur les tablespaces dans PostgreSQL ?",
        "options": [
            "pg_tablespace",
            "pg_database",
            "pg_class",
            "pg_tables"
        ],
        "correct": 0,
        "explanation": "Le catalogue pg_tablespace contient les m√©tadonn√©es sur les tablespaces d√©finis dans un cluster PostgreSQL."
    }
]


def shuffle_questions():
    """M√©lange les questions pour chaque session"""
    random.shuffle(questions)


def display_question(q_index):
    """Affiche une question selon son type"""
    if q_index >= len(questions):
        return None

    question = questions[q_index]
    st.write(f"**Question {q_index + 1}/{len(questions)}**")
    st.write(question["question"])

    if question["type"] == "mcq":
        return st.radio("Choisissez votre r√©ponse:", question["options"], key=f"q_{q_index}")

    elif question["type"] == "multiple":
        st.write("*Plusieurs r√©ponses possibles*")
        selected = []
        for i, option in enumerate(question["options"]):
            if st.checkbox(option, key=f"q_{q_index}_{i}"):
                selected.append(i)
        return selected

    elif question["type"] == "code":
        st.code(question["code_template"], language="sql")
        return st.text_input("Compl√©tez le code:", key=f"q_{q_index}")


def check_answer(q_index, user_answer):
    """V√©rifie si la r√©ponse est correcte"""
    question = questions[q_index]

    if question["type"] == "mcq":
        return user_answer == question["correct"]

    elif question["type"] == "multiple":
        return set(user_answer) == set(question["correct"])

    elif question["type"] == "code":
        return user_answer.upper().strip() == question["correct"].upper()


def main():
    st.title("üóÑÔ∏è QCM Administration Avanc√©e de Bases de Donn√©es")
    st.subheader("Cours L3 - IUT Informatique Belfort")

    # Sidebar avec informations
    with st.sidebar:
        st.header("üìä Informations")
        if st.session_state.quiz_started:
            st.metric("Question actuelle", f"{st.session_state.current_question + 1}/{len(questions)}")
            st.metric("Score actuel",
                      f"{st.session_state.score}/{st.session_state.current_question + 1}" if st.session_state.current_question > 0 else "0/0")
            progress = (st.session_state.current_question + 1) / len(questions)
            st.progress(progress)

        st.markdown("---")
        st.markdown("**Th√®mes couverts :**")
        st.markdown("""
        - üóÇÔ∏è Gestion des espaces de donn√©es
        - üë• Gestion des utilisateurs  
        - üíæ Backup/Restore
        - üîÑ R√©plication
        - üåê F√©d√©ration
        - üåç Internationalisation
        - üìà Types de bases de donn√©es
        """)

    # Page d'accueil
    if not st.session_state.quiz_started:
        st.markdown("""
        ### Bienvenue dans votre QCM de r√©vision !

        Ce quiz contient **12 questions** sur les concepts avanc√©s d'administration de bases de donn√©es :

        - **Questions √† choix multiples** (QCM classiques)
        - **Questions √† choix multiples** (plusieurs r√©ponses possibles)  
        - **Questions de code** (compl√©ter des commandes SQL)

        Cliquez sur le bouton ci-dessous pour commencer !
        """)

        col1, col2, col3 = st.columns([1, 1, 1])
        with col2:
            if st.button("üöÄ Commencer le QCM", size="large"):
                shuffle_questions()
                st.session_state.quiz_started = True
                st.session_state.current_question = 0
                st.session_state.score = 0
                st.session_state.answers = []
                st.rerun()

    # Quiz en cours
    elif st.session_state.quiz_started and not st.session_state.quiz_finished:
        current_q = st.session_state.current_question

        if current_q < len(questions):
            user_answer = display_question(current_q)

            col1, col2 = st.columns([1, 1])

            with col1:
                if st.button("‚¨ÖÔ∏è Question pr√©c√©dente", disabled=current_q == 0):
                    if current_q > 0:
                        st.session_state.current_question -= 1
                        st.rerun()

            with col2:
                if current_q == len(questions) - 1:
                    if st.button("üèÅ Terminer le QCM"):
                        if user_answer is not None:
                            is_correct = check_answer(current_q, user_answer)
                            st.session_state.answers.append({
                                'question': questions[current_q]["question"],
                                'user_answer': user_answer,
                                'correct': is_correct,
                                'explanation': questions[current_q]["explanation"]
                            })
                            if is_correct:
                                st.session_state.score += 1
                            st.session_state.quiz_finished = True
                            st.rerun()
                else:
                    if st.button("‚û°Ô∏è Question suivante"):
                        if user_answer is not None:
                            is_correct = check_answer(current_q, user_answer)
                            st.session_state.answers.append({
                                'question': questions[current_q]["question"],
                                'user_answer': user_answer,
                                'correct': is_correct,
                                'explanation': questions[current_q]["explanation"]
                            })
                            if is_correct:
                                st.session_state.score += 1
                            st.session_state.current_question += 1
                            st.rerun()

    # R√©sultats finaux
    else:
        st.balloons()

        score_percentage = (st.session_state.score / len(questions)) * 100

        st.markdown(f"""
        ## üéâ QCM Termin√© !

        ### Votre score : {st.session_state.score}/{len(questions)} ({score_percentage:.1f}%)
        """)

        # Affichage du niveau
        if score_percentage >= 80:
            st.success("üèÜ Excellent ! Vous ma√Ætrisez parfaitement le cours !")
        elif score_percentage >= 60:
            st.info("üëç Bien ! Quelques r√©visions et ce sera parfait !")
        else:
            st.warning("üìö Il faut r√©viser ! Relisez le cours attentivement.")

        # D√©tail des r√©ponses
        st.markdown("### üìã D√©tail de vos r√©ponses")

        for i, answer in enumerate(st.session_state.answers):
            with st.expander(f"Question {i + 1} - {'‚úÖ Correct' if answer['correct'] else '‚ùå Incorrect'}"):
                st.write(f"**Question :** {answer['question']}")
                st.write(f"**Votre r√©ponse :** {answer['user_answer']}")
                st.info(f"**Explication :** {answer['explanation']}")

        # Bouton recommencer
        col1, col2, col3 = st.columns([1, 1, 1])
        with col2:
            if st.button("üîÑ Recommencer le QCM"):
                st.session_state.quiz_started = False
                st.session_state.quiz_finished = False
                st.session_state.current_question = 0
                st.session_state.score = 0
                st.session_state.answers = []
                st.rerun()


if __name__ == "__main__":
    main()